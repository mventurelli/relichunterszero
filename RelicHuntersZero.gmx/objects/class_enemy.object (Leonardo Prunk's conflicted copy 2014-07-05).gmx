<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_enemy</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Main Shit
shield = true;
energy_max = 100;
energy = energy_max;
hp_max = 80;
hp = hp_max;
critical_death = false;

weakspot = instance_create(x,y,obj_weakspot1);

speed_walk = 2.5;
speed_sprint = 3.2;
move_speed = speed_walk;

dodging = false;

//AI
randomize_supression = irandom_range(-1,1);
ai_supression = randomize_supression;

aggro = random_range(0,50);
aggro_max = 200;
aggro_distance = 150;
aggro_add_patrol = 0.25;
aggro_add_close = 2;
aggro_add_hit = aggro_max;
aggro_cost_attack = 20;
aggro_cost_chase = 1;
aggro_min_chase = 120;

ai_state = 'PATROL';
ai_patrol_range = 400;
ai_patrol_x = -1;
ai_patrol_y = -1;

ai_cover_x = -1;
ai_cover_y = -1;
ai_cover_priority = ds_priority_create();
ai_cover_check_range = 400;
ai_cover_hp_threshold = hp_max*0.5;

ai_path = path_add();
path_point_current = 0;
collision_mass = 1+random(1);


//VFX
hit_taken = false;
hit_taken_max = room_speed*0.1;
hit_taken_count = 0;
hit_direction = 0;

pushed = false;
push_direction = 0;
push_speed = 0;
push_friction = 0.5;
push_duration = room_speed*0.3;
push_duration_current = 0;

//Shield
shield = true;
energy_regen_time = room_speed*5;
energy_regen_time_current = 0;
energy_regen_speed = 1;

shield_fading = false;
shield_alpha = 0;
shield_alpha_speed = 0;
shield_alpha_accel = 0.2;
shield_alpha_speed_max = 2;

//Weapons
look_direction = 1;
firing = false;

fire_range = 350;

my_pistol = instance_create(x,y,obj_pistol_enemy);
my_pistol.owner = id;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>-1</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>global.pause</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animation &amp; VFX

if (look_direction == 1) image_xscale = 1;
else image_xscale = -1;

//Hit Taken
if (hit_taken)
{   
    energy_regen_time_current = 0;
    
    if (shield)
    {
        shield_effect = instance_create(x,y,fx_shield);
        shield_effect.owner = id;
        hit_taken = false;
    }
    
    if (!shield)
    {
        hit_taken_count++;
        
        if (hit_taken_count &gt;= hit_taken_max) hit_taken = false;
        if (image_index == image_number-1) image_speed = 0;
        
        if hit_taken_count = 1
        {
            sprite_index = spr_enemy_hit;
            image_speed = 0.3;
            image_index = 0;
        }
    }
}
else
{
    sprite_index = spr_enemy;
    image_speed = 0.3;
    hit_taken_count = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Life, Shield &amp; Death

weakspot.x = x;
weakspot.y = y;

if hp &lt;= 0
{
    if (!critical_death) 
    {
        global.pause = room_speed*0.1;
        score_add(global.score_kill,false);
    }
    else
    {
        global.pause = room_speed*0.4;
        score_add(global.score_kill+global.score_headshot,true);
    }
    weakspot.destroy = true;
    instance_destroy();
}

//Shield
if energy &lt; energy_max
{
    energy_regen_time_current++;
    if energy_regen_time_current &gt;= energy_regen_time
    {
        if (!energy) energy = 1;
        shield = true;
        energy += energy_regen_speed;
        if (energy &gt; energy_max) energy = energy_max;
    }
}

if (!energy) &amp;&amp; (shield == true)
{
    myShieldEffect = instance_create(x,y,fx_shield_explosion);
    myShieldEffect.owner = id;
    shield = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///AI &amp; Movement
ai_movetarget_x = -1;
ai_movetarget_y = -1;
ai_target = noone;
current_distance = 0;
move_speed = speed_walk;
firing = false;

if instance_exists(class_player) &amp;&amp; (!pushed)
{
    //Aggro Control
    if (point_distance(x,y,class_player.x,class_player.y) &lt;= aggro_distance) aggro += aggro_add_close;
    if (ai_state == 'PATROL' || ai_state == 'COVER') aggro += aggro_add_patrol;
    if (ai_state == 'CHASE') aggro -= aggro_cost_chase;
    
    if (aggro &lt; 0) aggro = 0;
    if (aggro &gt; aggro_max) aggro = aggro_max;
    
    if (shield == false) &amp;&amp; (hp &gt; ai_cover_hp_threshold) 
    {
        ai_state = 'COVER';
    }
    
    //State Switches
    if ai_state == 'CHASE'
    {
        if (aggro &lt;= 0) { ai_state = 'PATROL'; exit; }
    }
    
    if ai_state == 'COVER'
    {
        if (energy &gt;= energy_max) 
        { 
            ai_state = 'PATROL'; 
            exit; 
        }
        if (hp &lt;= ai_cover_hp_threshold) 
        { 
            ai_state = 'CHASE'; 
            exit; 
        }
    }
    
    if ai_state == 'PATROL'
    {
        if aggro &gt;= aggro_min_chase
        {
            ai_state = 'CHASE';
            exit;
        }
    }
    
    //State Descriptions
    if ai_state == 'CHASE'
    {
        sight_blocked = (collision_line(x,y,class_player.x,class_player.y,class_solid,false,true));
    
        if (point_distance(x,y,class_player.x,class_player.y) &gt; fire_range) || ( (sight_blocked) &amp;&amp; (!ai_supression) )
        {
            ai_movetarget_x = class_player.x;
            ai_movetarget_y = class_player.y;
            firing = false;
        }
        else
        {
            ai_movetarget_x = x;
            ai_movetarget_y = y;
            firing = true;
        }
    }
    
    if ai_state == 'COVER'
    {
        move_speed = speed_sprint;
        if (point_distance(x,y,class_player.x,class_player.y) &lt;= fire_range) firing = true;
        
        //Checks for nearby covers
        if ds_priority_empty(ai_cover_priority)
        {
            cover_count = instance_number(obj_wall);
            for (i=0; i&lt;cover_count; i++)
            {
                cover_candidate = instance_find(obj_wall,i);
                cover_distance = point_distance(x,y,cover_candidate.x,cover_candidate.y);
                if cover_distance &lt;= ai_cover_check_range
                {
                    ds_priority_add(ai_cover_priority,cover_candidate,cover_distance);
                }    
            }
        }
        
        //Look for best closest cover position against player (checks 4 sides)
        if (!ds_priority_empty(ai_cover_priority)) &amp;&amp; (ai_cover_x == -1) &amp;&amp; (ai_cover_y == -1)
        {
            tile_size = 64;
            current_distance = 99999;
            for (i=0; i&lt;ds_priority_size(ai_cover_priority); i++)
            {
                cover_candidate = ds_priority_delete_min(ai_cover_priority);
                //Side 1
                checkX = cover_candidate.x-(tile_size/2);
                checkY = cover_candidate.y+(tile_size/2);
                if (!collision_point(checkX,checkY,obj_wall,false,true)) &amp;&amp; (collision_line(checkX,checkY,class_player.x,class_player.y,obj_wall,false,true))
                {
                    candidate_distance = point_distance(x,y,ai_cover_x,ai_cover_y)
                    if candidate_distance &lt; current_distance { ai_cover_x = checkX; ai_cover_y = checkY; current_distance = candidate_distance; }
                }
                //Side2
                checkX = cover_candidate.x+(tile_size*1.5);
                checkY = cover_candidate.y+(tile_size/2);
                if (!collision_point(checkX,checkY,obj_wall,false,true)) &amp;&amp; (collision_line(checkX,checkY,class_player.x,class_player.y,obj_wall,false,true))
                {
                    candidate_distance = point_distance(x,y,ai_cover_x,ai_cover_y)
                    if candidate_distance &lt; current_distance { ai_cover_x = checkX; ai_cover_y = checkY; current_distance = candidate_distance; }
                }
                //Side3
                checkX = cover_candidate.x+(tile_size/2);
                checkY = cover_candidate.y-(tile_size/2);
                if (!collision_point(checkX,checkY,obj_wall,false,true)) &amp;&amp; (collision_line(checkX,checkY,class_player.x,class_player.y,obj_wall,false,true))
                {
                    candidate_distance = point_distance(x,y,ai_cover_x,ai_cover_y)
                    if candidate_distance &lt; current_distance { ai_cover_x = checkX; ai_cover_y = checkY; current_distance = candidate_distance; }
                }
                //Side4
                checkX = cover_candidate.x+(tile_size/2);
                checkY = cover_candidate.y+(tile_size*1.5);
                if (!collision_point(checkX,checkY,obj_wall,false,true)) &amp;&amp; (collision_line(checkX,checkY,class_player.x,class_player.y,obj_wall,false,true))
                {
                    candidate_distance = point_distance(x,y,ai_cover_x,ai_cover_y)
                    if candidate_distance &lt; current_distance { ai_cover_x = checkX; ai_cover_y = checkY; current_distance = candidate_distance; }
                } 
            }
        }
        
        //Resolve
        if (ai_cover_x) &amp;&amp; (ai_cover_y)
        {
            ai_movetarget_x = ai_cover_x;
            ai_movetarget_y = ai_cover_y;
            
            if point_distance(x,y,ai_cover_x,ai_cover_y) &lt; 20
            {
                ai_cover_x = -1;
                ai_cover_y = -1;
                ds_priority_clear(ai_cover_priority);
            }
        }
        
    }
    
    if ai_state == 'PATROL'
    {
        if (ai_patrol_x) &amp;&amp; (ai_patrol_y)
        {
            if (collision_point(ai_patrol_x,ai_patrol_y,class_solid,false,true) &lt; 0)
            {
                ai_movetarget_x = ai_patrol_x;
                ai_movetarget_y = ai_patrol_y;
            }
            else
            {
                ai_movetarget_x = x;
                ai_movetarget_y = y;
            }
        }
        else
        {
            ai_patrol_x = x+(random_range(-400,400));
            ai_patrol_y = y+(random_range(-400,400));
        }
    }
    else
    {
        ai_patrol_x = -1;
        ai_patrol_y = -1;
    }
}


//Look Direction
if instance_exists(class_player)
{
    if (class_player.x &gt; x) look_direction = 1;   
    else look_direction = 0;
}

//Resolve
path_update();


// Push
if (pushed)
{
    path_end();
    move_step_ext(x + lengthdir_x(push_speed, push_direction),y + lengthdir_y(push_speed, push_direction),0,class_solid,0,0,0,0,0,0);

    push_speed -= push_friction;
    if push_speed &lt; 0 push_speed = 0;
    
    push_duration_current++;
    if push_duration_current &gt;= push_duration
    {
        push_duration_current = 0;
        pushed = false;
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();

//Pause Animation
old_image_speed = image_speed;
if (global.pause)
{
    image_speed = 0;
    path_end();
}
else image_speed = old_image_speed;

//Shield
if (shield) draw_sprite_ext(spr_shield,0,x,y,1,1,0,c_white,shield_alpha);

//Debug
/*
draw_set_font(font_wendy12);
draw_text(x,y-30,ai_state);

if (ai_state == 'PATROL')
{
    draw_text(x,y+30,string(ai_patrol_x)+','+string(ai_patrol_y));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>36,36</point>
    <point>36,36</point>
  </PhysicsShapePoints>
</object>
