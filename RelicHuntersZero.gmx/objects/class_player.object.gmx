<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>faction_player</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup

myPlayerId = 1;
playerName = "NONAME";
myChar = char_jimmy;

setup_initial = false;
interactionKey = false;

myDynamicBar = instance_create(x,y,gui_dynamicBar);
myDynamicBar.owner = id;

isVulnerable = false;
alarm[0] = room_speed*2;

energy_max = 100;
energy = energy_max;
overshield = 0;
superShield = false;

hp_max = 100;
hp = hp_max;

hp_regen_time = room_speed*1;
hp_regen_time_current = 0;
hp_regen_amount = 2;

stamina_max = 100;
stamina = stamina_max;

base_accuracy = 1;

accPistol = 1;
accMachinegun = 1;
accShotgun = 1;
accSniper = 1;
accSmg = 1;
accRocket = 1;
accRifle = 1;
accKeytar = 1;
accFlame = 1;

stamina_regen = 0.32;
stamina_regen_regular = stamina_regen;
stamina_regen_relic = stamina_regen*2;

dodge_stamina = 50;
sprint_stamina = 0.3;
sprint_stamina_min = 10;

move_speed_max = 4.5;
move_speed_sprint = 5.5;
move_speed_aiming = 2;
move_accel = 1.5;
move_friction = 0.4;

dodge_speed = 35;
dodge_duration = room_speed*0.4;
dodge_time = 0;
dodgeFriction = 0.2;
dodge_doubletap_time = room_speed*0.2;
dodge_doubletap_time_current = dodge_doubletap_time;
dodge_doubletap_direction = 0;

myGrenadeObject = obj_grenadeNew;
grenade_speed = 7;

dashTimeWindow = room_speed*0.25;
dashTimeCurrent = 0;

pickupTimeWindow = room_speed*0.35;
pickupTimeCurrent = 0;
allowPickup = false;

moving = false;
sprinting = false;
sprintToggled = false;
dodging = false;
aiming = false;
move_direction = 0;
move_speed = 0;
look_direction = 1;

active_interaction = noone;

// Instantiate Guns
myGun = noone;

weapon1 = noone;
weapon2 = noone;

reloadBarObj = instance_create(x,y,gui_reload_bar);
reloadBarObj.owner = id;

// Animation
animation_priority = 0;
animation_index = 0;
animation_current = 'noone';
footStepTime = ((room_speed*0.2) * 1);
footStepTimeCurrent = 0;
animation_play('idle',0.2,an_loop,1,1);
image_speed = 0;

// Pickups
myPickupList = ds_priority_create();

// Power Ups
serendipity = false;
serendipity_duration = room_speed*10;
serendipity_duration_current = 0;

//Hit Taken
hit_taken = false;

//Shield
shield = true;

energy_regen_time = room_speed*5;
energy_regen_time_regular = energy_regen_time;
energy_regen_time_relic = round(energy_regen_time/2);

energy_regen_time_current = energy_regen_time;
energy_regen_speed = 1;

shield_fading = false;
shield_alpha = 0;
shield_alpha_speed = 0;
shield_alpha_accel = 0.2;
shield_alpha_speed_max = 2;

superShieldTime = 0;
superShieldTimeCurrent = 0;
mySuperShieldFx = noone;

//Biu's Shield
inputShield = false;

//Dash
myDash = instance_create(x,y,fx_player_dash);
myDash.owner = id;

//Melee
meleeDamageUpdated = false;
melee_damage = 100;
melee_push_power = 14;

melee = false;
melee_dash = false;
melee_image_speed = 0.2;
melee_hit_frame = 5;
melee_step_speed = 18;
melee_stamina_cost = 0;

melee_damage_gloves = 160;
melee_push_power_gloves = 15;
melee_step_speed_gloves = 25;

throw = false;

//Sprites
sprite_idle = spr_jimmy_idle;
sprite_walk = spr_jimmy_walk;
sprite_sprint = spr_jimmy_walk;
sprite_dash = spr_jimmy_walk;
sprite_hit = spr_jimmy_walk;
sprite_death = spr_jimmy_walk;
sprite_melee = spr_jimmy_walk;
sprite_dash_fx = spr_jimmy_walk;
sprite_dig = spr_jimmy_dig;

reflection_object_setup(0,-1,image_index);
shadow_object_setup(0,-1,-1,global.default_shadow_yscale);

//Sound

audio_emitter = audio_emitter_create();
audio_falloff_set_model(audio_falloff_linear_distance);
audio_emitter_falloff(audio_emitter, global.falloffMainDist, global.falloffMainMax, global.falloffMainFactor);
audio_emitter_gain(audio_emitter,global.soundVolume);

play_sound_pickup_weapon = false;
if (room != room_start) audio_play(audio_emitter, false, 1, sfx_teleport);


//Digging
isDigging = false;
digDepth = 0;
digSpeed = 4;
digDepthMax = 42;
digRate = room_speed*0.3;
digRateCurrent = digRate;

//Global Input Lock on Game Enter + Unpause
inputLocked = true;
inputLockTime = room_speed*0.25;
inputLockTimeCurrent = 0;

//Joystick
joyLookDirection = 0;
joyLookTargetAngle = 0;
joyAimLocked = false;
targetEnemy = noone;

joyMoveDeadzoneMin = 0.3;
joyMoveDeadZoneMax = 0.65;
joyMoveSlowSpeed = 0.5;

joyAutoAimSpeedIn = 0.75;
joyAutoAimSpeedOut = 0.6;
joyAutoAimAdjustment = 0;

joyAutoAimSnapAngle = 5;

joyIsRightStickAiming = false;
joyAimStickVector = 0;

joyCrosshairDistance = 0;
joyCrosshairDistanceTarget = 0;
joyCrosshairDistanceSpeed = 30;
joyCrosshairDistanceMin = 40;

joyCrosshairSpeed = 24;

//Relics and Challenges
staminaChallengeUpdated = false;
staminaRelicUpdated = false;
energyRegenUpdated = false;

hpPuddingUpdated = false;
hpPieUpdated = false;
energyDriveUpdated = false;
energyProcessorUpdated = false;

receivedCrystalBaconHealing = false;

//Special Character Stuff
riderGrenadeCost = 0;
riderDodgeAttack = noone;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CleanUp
audio_emitter_free(audio_emitter);
//ds_priority_destroy(myPickupList); This is crashing the game for some reason?!?!
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Make player vulnerable after spawning

isVulnerable = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Crosshair Position &amp; AutoAim
if (global.input[myPlayerId] == K_INPUT_KEYBOARD)
{
    global.crosshairX[myPlayerId] = mouse_x;
    global.crosshairY[myPlayerId] = mouse_y;
}

if (global.input[myPlayerId] != K_INPUT_KEYBOARD) &amp;&amp; instance_exists(class_player) &amp;&amp; instance_exists(myGun)
{
    var joy = global.input[myPlayerId];
    var autoAimAngle = global.autoAimAngle;

    var joyLookAngularVelocity, joyLookDeadzone, enemyDistance;
    
    joyLookDeadzone = 0.55;
    
    if (aiming)
    {
        joyLookAngularVelocity = 5;
        
        if (global.sticky_aim == true) &amp;&amp; instance_exists(class_enemy)
        {
            if (collision_line(x, y, x+lengthdir_x(800,joyLookDirection), y+lengthdir_y(800,joyLookDirection), class_enemy, false, true))
            {
                joyLookAngularVelocity = 2;
            }
        }
        
        if (global.auto_aim != K_AUTOAIM_OFF)
        {
            targetEnemy = find_enemy_autoaim(x,y, joyLookTargetAngle, autoAimAngle, myGun.projectile_range );
            
            if (targetEnemy) &amp;&amp; instance_exists(targetEnemy)
            {
                joyAimLocked = true;
            }
        }
        
        if (joyAimLocked)
        {
            if (targetEnemy) &amp;&amp; instance_exists(targetEnemy)
            {
                joyLookDirection = autoaim_angle(x,y,targetEnemy);
                if (abs(angle_difference(joyLookDirection,joyLookTargetAngle) &gt; autoAimAngle)) joyAimLocked = false;
            }
            else joyAimLocked = false;
        }
    }
    else
    {
        joyLookAngularVelocity = 30;
        joyAimLocked = false;
    }
    
    //Full Autoaim
    if (global.auto_aim == K_AUTOAIM_FULL)
        {
            autoAimAngle = 360;
            
            var candidate = find_enemy_autoaim(x,y, joyLookTargetAngle, autoAimAngle, myGun.projectile_range );
            if (targetEnemy != candidate)
            {
                global.crosshair_scale[myPlayerId] = 1.85;
                targetEnemy = candidate;
            }
               
            if (targetEnemy) &amp;&amp; instance_exists(targetEnemy)
            {
                var targetEnemyBBoxCenter = get_bbox_center(targetEnemy);
                var aimingX = targetEnemyBBoxCenter[0];
                var aimingY = targetEnemyBBoxCenter[1];
                    
                joyLookDirection = autoaim_angle(x,y,targetEnemy);  
                joyLookTargetAngle = joyLookDirection;
                joyCrosshairDistance = point_distance(x,y,aimingX,aimingY);
                joyAimLocked = true;
            }
            
            if (aiming) joyLookTargetAngle = joyLookDirection;
        }
    
    //Crosshair Distance Resolve
    
    joyIsRightStickAiming = joy_simple_deadzone( joy_x2pos(joy), joy_y2pos(joy), joyLookDeadzone);
    
    if (joyIsRightStickAiming) joyLookTargetAngle = point_direction(x,y,(x+joy_x2pos(joy)),(y+joy_y2pos(joy)));
    else if (!aiming) &amp;&amp; (joy_simple_deadzone( joy_xpos(joy), joy_ypos(joy), joyLookDeadzone)) joyLookTargetAngle = point_direction(x,y,(x+joy_xpos(joy)),(y+joy_ypos(joy))); //Direction set by movement stick
        
    if (!joyAimLocked)
    {   
        joyLookDirection = angle_rotate(joyLookDirection, joyLookTargetAngle, joyLookAngularVelocity); 
    }
    
    if !(global.auto_aim == K_AUTOAIM_FULL &amp;&amp; aiming)//joyAimLocked)
    {
        var joyAimVector = point_distance(0, 0, joy_x2pos(joy), joy_y2pos(joy) );
        if (joyIsRightStickAiming) joyCrosshairDistanceTarget = 320 * joyAimVector;
        else joyCrosshairDistanceTarget = joyCrosshairDistanceMin;
        
        if (joyCrosshairDistance != joyCrosshairDistanceTarget)
        {
            if (joyCrosshairDistance &lt; joyCrosshairDistanceTarget) joyCrosshairDistance += min( joyCrosshairDistanceSpeed, abs(joyCrosshairDistanceTarget-joyCrosshairDistance) );
            else joyCrosshairDistance -= min( joyCrosshairDistanceSpeed, abs(joyCrosshairDistanceTarget-joyCrosshairDistance) );
        }
    }
        
    //Final Crosshair Position
    var targetCrossX = x + lengthdir_x(joyCrosshairDistance, joyLookDirection);
    var targetCrossY = y + lengthdir_y(joyCrosshairDistance, joyLookDirection);
    var targetCrossDir = point_direction(global.crosshairX[myPlayerId], global.crosshairY[myPlayerId], targetCrossX, targetCrossY);
    var targetCrossDist = point_distance(global.crosshairX[myPlayerId], global.crosshairY[myPlayerId], targetCrossX, targetCrossY);
    var targetSpeed = min(joyCrosshairSpeed, targetCrossDist);
    
    if (global.auto_aim == K_AUTOAIM_FULL) targetSpeed = targetCrossDist;
    
    global.crosshairX[myPlayerId] = global.crosshairX[myPlayerId] + lengthdir_x( targetSpeed , targetCrossDir);
    global.crosshairY[myPlayerId] = global.crosshairY[myPlayerId] + lengthdir_y( targetSpeed , targetCrossDir);
}



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Release Input Lock

if (inputLocked) {
    if (inputLockTimeCurrent &lt; inputLockTime) inputLockTimeCurrent++;
    else {
        inputLocked = false;
        inputLockTimeCurrent = 0;
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Relic Buffs, Challenges, Invulnerability, Achievements

//Invulnerable in first room
if (room == room_start) hp = hp_max;

// Relics
if (!staminaRelicUpdated){
    if (global.relic_alcoholic_carrot == 2) stamina_regen = stamina_regen_relic;
    else stamina_regen = stamina_regen_regular;
    
    staminaRelicUpdated = true;
}

staminaChallengeUpdated = false;
staminaRelicUpdated = false;



if (global.relic_infinity_battery == 2) energy_regen_time = energy_regen_time_relic;
else energy_regen_time = energy_regen_time_regular;

//New Relics - a.k.a. Too lazy to refactor this horrible gamejam code, so why not make it even worse? :sigh: 
if (global.relic_pineapple_pudding == 2) &amp;&amp; (!hpPuddingUpdated){
    hp_max += round(hp_max * global.relicHpBonus);
    hpPuddingUpdated = true;
}

if (global.relic_pineapple_pie == 2) &amp;&amp; (!hpPieUpdated){
    hp_max += round(hp_max * global.relicHpBonus);
    hpPieUpdated = true;
}

if (global.relic_yottabyte_drive == 2) &amp;&amp; (!energyDriveUpdated){
    energy_max += round(energy_max * global.relicEnergyBonus);
    energyDriveUpdated = true;
}

if (global.relic_yottabyte_processor == 2) &amp;&amp; (!energyProcessorUpdated){
    energy_max += round(energy_max * global.relicEnergyBonus);
    energyProcessorUpdated = true;
}

//Crystal Bacon on Level End
if (global.relic_crystal_bacon ==2) &amp;&amp; (instance_exists(controller_main)){
    if (controller_main.level_end) &amp;&amp; (!receivedCrystalBaconHealing){
        hp += min(hp_max*0.2, hp_max-hp);
                
        audio_play(audio_emitter,false,1,sfx_pickup_health);
                
        guiInfo = instance_create(x,y,gui_info);
        guiInfo.colorMain = c_white;
        guiInfo.myString = loc_key("INFO_HEALTHPLUS");
        guiInfo.owner = id;
        
        receivedCrystalBaconHealing = true;
    }
}

//Watchful Eye: See controller_main;
//Midnight Beer and Midnight Meal: See projectile_player and melee_arc
//Dev Potion: See class_gun
//Morning Star: See coin pickup
//The Rabbit Foot: You won't find out what it does here :)

// Challenges
if (global.challengeMedieval) &amp;&amp; (!meleeDamageUpdated) {
    melee_damage += round(melee_damage * global.challengeMedievalBonus);
    meleeDamageUpdated = true;
}

if (global.challengeHeavyBurden) &amp;&amp; (!staminaChallengeUpdated) {
    stamina_regen -= stamina_regen * global.challengeHeavyBurdenPenalty;
    staminaChallengeUpdated = true;
}

//Achievements
if (global.gameMode == gamemode_endless) {
    if (instance_exists(weapon1)) &amp;&amp; (instance_exists(weapon2)){
        if (weapon1.isRelicWeapon) &amp;&amp; (weapon2.isRelicWeapon) achievement_give("ACHIEVEMENT_RELICWEAPONS");    
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>-1</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>global.pause</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement &amp; Stamina

dodge_direction = -1;

var allowMovement;
if (isDigging) || (animation_current == 'dig') allowMovement = false;
else {
    allowMovement = true;
    speed = move_speed;
    direction = move_direction;
}

if (allowMovement)
{
    //Keyboard
    if (global.input[myPlayerId] == K_INPUT_KEYBOARD) &amp;&amp; (!dodging) &amp;&amp; (!melee_dash) &amp;&amp; (!inputLocked)
    {   
        //Movement
        if input_key_left() &amp;&amp; !input_key_up() &amp;&amp; !input_key_down() { motion_add(180,move_accel); dodge_direction = 180; }
        if input_key_right() &amp;&amp; !input_key_up() &amp;&amp; !input_key_down() { motion_add(0,move_accel); dodge_direction = 0; }
        if input_key_up() &amp;&amp; !input_key_right() &amp;&amp; !input_key_left() { motion_add(90,move_accel); dodge_direction = 90; }
        if input_key_down() &amp;&amp; !input_key_right() &amp;&amp; !input_key_left() { motion_add(270,move_accel); dodge_direction = 270; }
        if input_key_left() &amp;&amp; input_key_up() { motion_add(135,move_accel); dodge_direction = 135; }
        if input_key_left() &amp;&amp; input_key_down() { motion_add(225,move_accel); dodge_direction = 225; }
        if input_key_right() &amp;&amp; input_key_up() { motion_add(45,move_accel); dodge_direction = 45; }
        if input_key_right() &amp;&amp; input_key_down() { motion_add(315,move_accel); dodge_direction = 315; }
        
        //Sprinting
        if (input_key_sprint_toggle()) sprintToggled = true;
        
        if (input_key_sprint() || input_key_sprint_toggle()) &amp;&amp; (!melee)
        {
            if (sprinting) &amp;&amp; (stamina &lt; sprint_stamina) sprinting = false; 
            else if (stamina &gt;= sprint_stamina_min) sprinting = true;
            if (sprinting) sprintOriginalDirection = direction;
        }
        else if (!sprintToggled) sprinting = false;
        
        if (sprinting) &amp;&amp; (sprintToggled)
        {
            if ( abs(angle_difference(direction,sprintOriginalDirection)) &gt; 100) || (speed &lt; 2) || (stamina &lt; sprint_stamina) || (melee)
                sprinting = false;
        }
        
        if (!sprinting) sprintToggled = false;
        
        //Dodge
        if ( input_key_sprint() )
        {
            dashTimeCurrent++;
        }
        
        double_tap_dodge = false;
        
        if (global.doubleTapDodge)
        {
            if input_key_left_pressed()
            {
                if (dodge_doubletap_direction == 180) &amp;&amp; (dodge_doubletap_time_current &lt; dodge_doubletap_time) double_tap_dodge = true;
                else { dodge_doubletap_direction = 180; dodge_doubletap_time_current = 0; } 
            }
            if input_key_right_pressed()
            {
                if (dodge_doubletap_direction == 0) &amp;&amp; (dodge_doubletap_time_current &lt; dodge_doubletap_time) double_tap_dodge = true;
                else { dodge_doubletap_direction = 0; dodge_doubletap_time_current = 0; } 
            }
            if input_key_up_pressed()
            {
                if (dodge_doubletap_direction == 90) &amp;&amp; (dodge_doubletap_time_current &lt; dodge_doubletap_time) double_tap_dodge = true;
                else { dodge_doubletap_direction = 90; dodge_doubletap_time_current = 0; } 
            }
            if input_key_down_pressed()
            {
                if (dodge_doubletap_direction == 270) &amp;&amp; (dodge_doubletap_time_current &lt; dodge_doubletap_time) double_tap_dodge = true;
                else { dodge_doubletap_direction = 270; dodge_doubletap_time_current = 0; } 
            }
            dodge_doubletap_time_current++;
        }
        
        if ( (input_key_sprint_released() &amp;&amp; (dashTimeCurrent &lt;= dashTimeWindow) ) || (double_tap_dodge) ) &amp;&amp; (!melee)
        {
            if (stamina &gt;= dodge_stamina)
            {
                stamina -= dodge_stamina;
                dodging = true;
                speed = dodge_speed;
                if (dodge_direction == -1)
                {
                    dodge_direction = 180 + point_direction(x,y,global.crosshairX[myPlayerId],global.crosshairY[myPlayerId]);
                }
                if (!double_tap_dodge) direction = dodge_direction;
                else direction = dodge_doubletap_direction;
                
                audio_play(audio_emitter,false,1,sfx_dash1,sfx_dash2,sfx_dash3);
            }
            else{
                //Low Stamina Feedback
                guiInfo = instance_create(x,y,gui_info);
                guiInfo.colorMain = K_BETU_RED;
                guiInfo.myString = loc_key("INFO_LOWSTAMINA");
                guiInfo.owner = id;
                audio_play(audio_emitter, false, 1, sfx_pickup_full);
            }
        }
        
        if ( input_key_sprint_released() ) dashTimeCurrent = 0;
        
        //Aiming
        if input_key_aim() &amp;&amp; (!sprinting) &amp;&amp; (!melee) aiming = true;
        else aiming = false;
    }
    
    //////////////////////////////////////////////////////////////
    //Joystick
    if global.input[myPlayerId] != K_INPUT_KEYBOARD &amp;&amp; (!dodging) &amp;&amp; (!melee_dash) &amp;&amp; (!inputLocked)
    {
        var joy = global.input[myPlayerId];
        
        //Movement
        if (joy_simple_deadzone( joy_xpos(joy), joy_ypos(joy), joyMoveDeadzoneMin))
        {
            var joy_direction = point_direction(x,y,(x+joy_xpos(joy)),(y+joy_ypos(joy)));
            motion_add(joy_direction, move_accel);
            dodge_direction = joy_direction;
        }
        
        //Sprinting
        if (joy_check(joy,9) || joy_check(joy,1)) &amp;&amp; (!melee)
        {
            if (sprinting) &amp;&amp; (stamina &lt; sprint_stamina) sprinting = false; 
            else if (stamina &gt;= sprint_stamina_min) sprinting = true;
            if (sprinting) sprintOriginalDirection = direction;
        }
        else if (!global.sprint_toggle) sprinting = false;
        
        if (sprinting) &amp;&amp; (global.sprint_toggle)
        {
            if ( abs(angle_difference(direction,sprintOriginalDirection)) &gt; 100) || (speed &lt; 2) || (stamina &lt; sprint_stamina) || (melee)
                sprinting = false;
        }
        
        //Dodging
        if joy_check(joy,1)
        {
            dashTimeCurrent++;
        }
        
        if joy_check_released(joy,1)
        {
            if (dashTimeCurrent &lt;= dashTimeWindow) &amp;&amp; (!melee)
            {
                if (stamina &gt;= dodge_stamina)
                {
                    sprinting = false;
                    stamina -= dodge_stamina;
                    dodging = true;
                    speed = dodge_speed;
                    
                    if (dodge_direction == -1)
                    {
                        dodge_direction = 180 + point_direction(x,y,global.crosshairX[myPlayerId],global.crosshairY[myPlayerId]);
                    }
                    
                    direction = dodge_direction;
                    audio_play(audio_emitter,false,1,sfx_dash1,sfx_dash2,sfx_dash3);
                }
                else{
                    //Low Stamina Feedback
                    guiInfo = instance_create(x,y,gui_info);
                    guiInfo.colorMain = K_BETU_RED;
                    guiInfo.myString = loc_key("INFO_LOWSTAMINA");
                    guiInfo.owner = id;
                    audio_play(audio_emitter, false, 1, sfx_pickup_full);
                }
            }
            dashTimeCurrent = 0; 
        }
        
        //Aiming
        if (joy_zpos(joy) &gt; 0.7) &amp;&amp; (!melee)
        {  
            sprinting = false;
            aiming = true;
        }
        else aiming = false;
    }
    
    ////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////
    
    //Look Direction
    if (!melee_dash)
    {
        var direction_check = (global.crosshairX[myPlayerId] - x);
        if (direction_check &gt; 0) look_direction = 1;
        else look_direction = 0;
    }
    
    
    //Melee Step
    if (melee) &amp;&amp; (animation_current = 'melee') &amp;&amp;(animation_index = melee_hit_frame)
    {
        speed = melee_step_speed;
        if (instance_exists(myGun)) if (myGun.isMeleeWeapon) speed = myGun.meleeStepSpeed;
        direction = point_direction(x,y,global.crosshairX[myPlayerId],global.crosshairY[myPlayerId]);
        melee_dash = true;
        
        if (direction &lt;= 90) || (direction &gt; 270) look_direction = 1;
        else look_direction = 0; 
    }
    
    //Friction
    if (!dodging) motion_add(direction-180,min(speed,move_friction));
    else motion_add(direction-180,min(speed,dodgeFriction));
    
    //Resolve Movement
    var totalSpeedVector = 1;
    if (global.input[myPlayerId] != K_INPUT_KEYBOARD)
    {
        var myJoy = global.input[myPlayerId];
        var currentThumbstick = joy_radial_vector( joy_xpos(myJoy), joy_ypos(myJoy));
        {
            if (currentThumbstick &gt; joyMoveDeadzoneMin) &amp;&amp; (currentThumbstick &lt; joyMoveDeadZoneMax) totalSpeedVector = joyMoveSlowSpeed;
        }
    }
    
    var maxSpeedAiming = move_speed_aiming*totalSpeedVector;
    var maxSpeed = move_speed_max*totalSpeedVector;
    var maxSpeedSprint = move_speed_sprint*totalSpeedVector;
    
    if speed &gt; maxSpeedAiming &amp;&amp; (aiming) speed -=min(move_accel,speed-maxSpeedAiming);
    if speed &gt; maxSpeed &amp;&amp; (!sprinting) speed -= min(move_accel,speed-maxSpeed);
    if speed &gt; maxSpeedSprint &amp;&amp; (sprinting) speed -= min(move_accel,speed-maxSpeedSprint);
    
    if (melee_dash) &amp;&amp; (speed == 0) melee_dash = false;
}

//Resolve    
move_speed = speed;
move_direction = direction;
speed = 0;
direction = 0;
    
if (move_speed)
{
    move_step_ext(x + lengthdir_x(move_speed, move_direction),y + lengthdir_y(move_speed, move_direction),0,class_solid,0,0,0,0,0,0); 
}
else sprinting = false;



// Reset Dodge
if (dodging)
{
    dodge_time++
    if dodge_time &gt;= dodge_duration
    {
        dodge_time = 0;
        dodging = false;
    }
}

// Stamina Management
if (sprinting) stamina -= sprint_stamina;
if stamina &lt; 0 stamina = 0;

if (!sprinting) &amp;&amp; (!dodging) &amp;&amp; (!melee) &amp;&amp; (!throw) &amp;&amp; !((myGun == obj_buckler)&amp;&amp;(inputShield)) stamina += stamina_regen;

if stamina &gt; stamina_max stamina = stamina_max;

// Stop Aiming When Reloading
global.check_weapon_reloading = false;

if (myGun) &amp;&amp; (instance_exists(myGun)) with(myGun)
{
    if (reloading) global.check_weapon_reloading = true;
}
if (global.check_weapon_reloading) aiming = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animation


// Look Direction
if !sprinting
{
    if look_direction == 0 image_xscale = -1;
    if look_direction == 1 image_xscale = 1;
}
else
{
    if (move_direction &gt; 90 &amp;&amp; move_direction &lt;= 270) image_xscale = -1;
    else image_xscale = 1;
}

//Hit Taken
if (hit_taken)
{
    energy_regen_time_current = 0;
    
    if (shield)
    {
        shield_effect = instance_create(x,y,fx_shield);
        shield_effect.owner = id;
        hit_taken = false;
        if (superShield) shield_effect.sprite_index = spr_supershield;
    }
    else
    {
        animation_play('hit',0.2,an_clamp,10,3);
        hit_taken = false;
        audio_play(audio_emitter,false,1,sfx_impact_flesh1,sfx_impact_flesh2,sfx_impact_flesh3,sfx_impact_flesh4);
    }
}

//Melee and Grenade Throw
if ((melee) || (throw)) animation_play('melee',0.25,an_clamp_forever,99,7+2);


//Move &amp; Idle
if (move_speed)
{
    if (sprinting) 
    {
        if (animation_current != 'sprint')
        {
            mySprintFx = instance_create(x,y,fx_sprint); 
            mySprintFx.image_xscale = image_xscale;
            audio_play_exclusive(audio_emitter,false,1,sfx_sprint);
        }
        animation_play('sprint',0.2,an_loop,1,6);
    }
    else if (dodging) animation_play('dash',0.2,an_loop,1,6);
    else if (aiming) animation_play('walk',0.2,an_loop,1,6);
    else animation_play('walk',0.2,an_loop,1,6);
}
else animation_play('idle',0.2,an_loop,1,12);

//Footsteps
var playFootstepSound = false;

if (animation_current == 'walk') || (animation_current == 'sprint')
{
    footStepTimeCurrent++;
    if (footStepTimeCurrent &gt;= footStepTime)
    {
        playFootstepSound = true;
        footStepTimeCurrent = 0;
    }
}
else footStepTimeCurrent = 0;

if (playFootstepSound) audio_play(audio_emitter,false,1,sfx_walk1,sfx_walk2,sfx_walk3,sfx_walk4,sfx_walk5);

// Resolve
depth = -y;
animation_update_player();


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Melee Attack + Biu's Shield

var input_melee = false;
var input_meleeWeapon = false;

if (global.input[myPlayerId] == K_INPUT_KEYBOARD)
{
    if input_key_melee_pressed()
    {
        input_melee = true;
    }
    
    if input_key_fire_pressed()
    {
        input_meleeWeapon = true;
    }
    
    if input_key_fire()
    {
        inputShield = true; // Biu's Shield
    }
    else inputShield = false;
}
else
{
    var joy = global.input[myPlayerId];
    
    if joy_check_pressed(joy,2)
    {
        input_melee = true;
    }
    
    if (joy_rpos(joy) &gt; 0.7)
    {
        input_meleeWeapon = true;
        inputShield = true;
    }
    else inputShield = false;
}

if (instance_exists(myGun)){
    if (!melee) &amp;&amp; (!throw)
    {
        if (input_melee) || ( myGun.isMeleeWeapon &amp;&amp; input_meleeWeapon )
        {
            melee = true;   
            if (myGun.isMeleeWeapon)
            {
                audio_play(audio_emitter,false,1,myGun.swingSound1,myGun.swingSound2,myGun.swingSound3,myGun.swingSound4,myGun.swingSound5,myGun.swingSound6,myGun.swingSound7);
            }
            else audio_play(audio_emitter,false,1,sfx_melee);
        }
    }
    
    if (melee) &amp;&amp; (animation_current == 'melee')
    {
        if (animation_index = melee_hit_frame)
        {
            meleeArc = instance_create(x,y,fx_melee_arc);
            meleeArc.owner = id;
            meleeArc.damage = melee_damage;
            
            meleeArc.push_power = melee_push_power;
            stamina -= melee_stamina_cost;
            if stamina &lt; 0 stamina = 0;
            
            if (myGun.isMeleeWeapon) 
            {
                meleeArc.damage = myGun.damage;
                meleeArc.max_hits = myGun.maxHits;  
                meleeArc.push_power = myGun.pushPower;
                meleeArc.sprite_index = myGun.meleeArcSprite;
            }  
        }
    
        if (animation_index &gt;= (animation_frames-1))
        {
            melee = false;
            animation_priority = 0;
        }
    }
}

//Rider's Dash attack
    
if (myChar == char_rider) &amp;&amp; (!instance_exists(riderDodgeAttack)) {
    if (dodging) {
        if (!riderDodgeAttack){
            riderDodgeAttack = instance_create(x,y,fx_melee_arc);
            riderDodgeAttack.owner = id;
            riderDodgeAttack.damage = melee_damage;  
            riderDodgeAttack.push_power = melee_push_power;
            riderDodgeAttack.max_hits = 5;
            audio_play(audio_emitter,false,1,sfx_kami_dash);
        }
    }
    else riderDodgeAttack = noone;
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Grenade Throw

var grenade_input = false;

if (global.input[myPlayerId] == K_INPUT_KEYBOARD)
{
    if input_key_grenade_pressed()
    {
        grenade_input = true;
    }
}
else
{
    var joy = global.input[myPlayerId];
    
    if (joy_check_pressed(joy,5))
    {
        grenade_input = true;
    }
}


if ( (grenade_input) &amp;&amp; (!melee) &amp;&amp; (!throw) )
{
        if (global.grenades[myPlayerId])
        {
            throw = true;
            audio_play(audio_emitter,false,1,sfx_melee);
        }
        else if (myChar != char_rider) || (hp &lt;= riderGrenadeCost){
            //Out of greandes feedback
            guiInfo = instance_create(x,y,gui_info);
            guiInfo.colorMain = K_BETU_RED;
            guiInfo.myString = loc_key("INFO_OUTOFGRENADES");
            guiInfo.owner = id;
            audio_play(audio_emitter, false, 1, sfx_pickup_full);
        }
        else{
            hp -= riderGrenadeCost;
            throw = true;
            audio_play(audio_emitter,false,1,sfx_melee);
            bloodAmount = min(5, (global.max_casings-global.count_casings));
            if (bloodAmount) repeat(bloodAmount) blood = instance_create(x,y,fx_blood);
            hit_taken = true;
            var spreadX = irandom_range(-15,15);
            var spreadY = irandom_range(-15,15);
            damage_fx = instance_create(x+spreadX,y+spreadY,fx_damage);
            damage_fx.damage = riderGrenadeCost;
        }
}


if (throw) &amp;&amp; (animation_current == 'melee')
{
    if (animation_index = melee_hit_frame)
    {
        global.grenades[myPlayerId]--;
    
        myGrenade = instance_create(x,y,myGrenadeObject);
        myGrenade.speed = grenade_speed;
        myGrenade.direction = point_direction(x,y,global.crosshairX[myPlayerId],global.crosshairY[myPlayerId]);
    }

    if (animation_index &gt;= (animation_frames-1))
    {
        throw = false;
        animation_priority = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Weapon Switch

var switch_input = false;

if (weapon2 != noone)
{
    if (global.input[myPlayerId] == K_INPUT_KEYBOARD)
    {
        if ( input_key_switch_pressed() ) || ( global.allowMouseWheel &amp;&amp; (mouse_wheel_up() || mouse_wheel_down()) )
        {
            switch_input = true;
        }
    }
    else
    {
        var joy = global.input[myPlayerId];
        
        if (joy_check_pressed(joy,4))
        {
            switch_input = true;
        }
    }
}


if (switch_input)
{
    //Stop reloading sound
    if (audio_is_playing(sfx_reload_loop1)) audio_stop_sound(sfx_reload_loop1);
    if (audio_is_playing(sfx_reload_loop2)) audio_stop_sound(sfx_reload_loop2);
    if (audio_is_playing(sfx_reload_loop3)) audio_stop_sound(sfx_reload_loop3);
    
    //Switch
    if myGun == weapon1 
    {
        draw_gun(weapon2);
        audio_play(audio_emitter,false,1,sfx_weapon_switch);
        exit;
    }
    if myGun == weapon2
    {
        draw_gun(weapon1);
        audio_play(audio_emitter,false,1,sfx_weapon_switch);
        exit;
    }
}

if (instance_exists(weapon2)) &amp;&amp; (!instance_exists(weapon1))
{
    weapon1 = weapon2;
    weapon2 = noone;
    draw_gun(weapon1);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Health, Shield, Death

//Health
if (hp &gt;= hp_max) hp = hp_max;

if (hp &lt;= 0) 
{
    global.playerAlive[myPlayerId] = false;
    corpse = instance_create(x,y,fx_corpse_player);
    if (global.character[myPlayerId] == char_jimmy) corpse.sprite_index = spr_jimmy_death;
    if (global.character[myPlayerId] == char_pinky) corpse.sprite_index = spr_pinky_death;
    if (global.character[myPlayerId] == char_raff) corpse.sprite_index = spr_raff_death;
    if (global.character[myPlayerId] == char_biu) corpse.sprite_index = spr_biu_death;
    if (global.character[myPlayerId] == char_punny) corpse.sprite_index = spr_punny_death;
    if (global.character[myPlayerId] == char_ass) corpse.sprite_index = spr_ass_death;
    if (global.character[myPlayerId] == char_rider) corpse.sprite_index = spr_rider_death;
    instance_destroy();
}
else hp = round(hp);

//Shield
if energy &lt; (energy_max+overshield)
{
    energy_regen_time_current++;
    if energy_regen_time_current &gt;= energy_regen_time
    {
        if (!energy) energy = 1;
        shield = true;
        energy += energy_regen_speed;
        if (energy &gt; (energy_max+overshield)) energy = energy_max+overshield;
    }
    if energy_regen_time_current = energy_regen_time
    {
        myRecharge = instance_create(x,y,fx_shield_up);  
        audio_play(audio_emitter,false,1,sfx_shield_regen_start);
        myRecharge.owner = id;
    }
    
    if (energy &lt; 0) energy = 0;
}

if (!energy) &amp;&amp; (shield == true) &amp;&amp; (energy_max)
{
    if (overshield)
    {
        overshield = 0;
        guiInfo = instance_create(x,y,gui_info);
        guiInfo.colorMain = K_BETU_RED;
        guiInfo.myString = loc_key("INFO_SHIELDLOST");
        guiInfo.owner = id;
    }
    
    myShieldEffect = instance_create(x,y,fx_shield_explosion);
    myShieldEffect.owner = id;
    mySparks = instance_create(x,y,fx_shield_down);
    mySparks.owner = id;
    shield = false;
    
    if (global.challengeOvercharge) hp -= global.challengeOverchargeDamage;
}

if (!energy_max) shield = false;

if (superShield){
    energy = energy_max+overshield;
    shield = true;

    if (!instance_exists(mySuperShieldFx)) {
        mySuperShieldFx = instance_create(x,y,fx_superShield);
        mySuperShieldFx.owner = id;
        audio_play(audio_emitter,false,9,sfx_shield_regen_start);
    }
    
    if (superShieldTimeCurrent &lt; superShieldTime) superShieldTimeCurrent++;
    else{
        superShieldTimeCurrent = 0;
        superShieldTime = 0;
        superShield = false;
        if (instance_exists(mySuperShieldFx)) with (mySuperShieldFx){instance_destroy();}
        instance_create(x,y,fx_explosion_shield);
    }   
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Interaction and Reload

if (!instance_exists(active_interaction))
{
    active_interaction = noone;
}

interactionKey = false;
reloadKey = false;

if (global.input[myPlayerId] == K_INPUT_KEYBOARD)
{
    if ( input_key_use_pressed() ) interactionKey = true;
    if ( input_key_reload_pressed() ) reloadKey = true;
}
else
{   
    var joy = global.input[myPlayerId];
    
    if joy_check_released(joy,3) &amp;&amp; (pickupTimeCurrent &lt; pickupTimeWindow)
    {
        reloadKey = true;
        if (global.relicDetected) interactionKey = true;//Hack 
    }
    
    if joy_check(joy,3) 
    {
        if (allowPickup) pickupTimeCurrent++;
    }
    else 
    {
        if (pickupTimeCurrent) pickupTimeCurrent--; 
        allowPickup = true;
    }
    
    if (pickupTimeCurrent &gt;= pickupTimeWindow) &amp;&amp; (allowPickup)
    {
        interactionKey = true;
        allowPickup = false;
    }
}

///Draw dynamic ammo bars when you press the reload key
if (reloadKey)
{
    if (instance_exists(global.dynamicAmmo1))
    {
        if (myPlayerId == 1) { global.dynamicAmmo1.timedActive = true; global.dynamicAmmo1.activeTimeCurrent = 0; }
        if (myPlayerId == 2) { global.dynamicAmmo2.timedActive = true; global.dynamicAmmo2.activeTimeCurrent = 0; }
    }
}

///Check for nearby interactive objects, activate if key is pressed
if (instance_exists(class_interactive_master))
{
    ds_priority_clear(myPickupList);
    var countPickups = instance_number(class_interactive_master);
    for (var i=0; i&lt;countPickups; i++)
    {
        var pickupCurrent = instance_find(class_interactive_master,i);
        if (instance_exists(pickupCurrent))
        {
            var pickupDist = point_distance(x,y,pickupCurrent.x,pickupCurrent.y);
            if (pickupDist &lt;= pickupCurrent.range) &amp;&amp; (pickupCurrent.isInteractiveObjectActive) ds_priority_add(myPickupList, pickupCurrent, pickupDist);
        }
    }
    
    var myPickupInRange = noone;
    if (!ds_priority_empty(myPickupList)) myPickupInRange = ds_priority_find_min(myPickupList);
    
    if (instance_exists(myPickupInRange))
    {
        if (myPickupInRange.isClientLocked == false) myPickupInRange.activationClient = id;
        
        if (interactionKey) 
        {
            myPickupInRange.wantToActivate = true;
            myPickupInRange.isClientLocked = true;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Audio
audio_emitter_position(audio_emitter, x, y, 0);

if (play_sound_pickup_weapon)
{
    play_sound_pickup_weapon = false;
    audio_play(audio_emitter,false,1,sfx_pickup_weapon);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Digging

if (global.relicDetected) 
{
    if instance_exists(obj_digSpot) &amp;&amp; (interactionKey) &amp;&amp; (digRateCurrent &gt;= digRate) 
    {
        var digStartDistance = 90;
    
        animation_play('dig',0.15,an_clamp,99,3+2);
        audio_play_exclusive(audio_emitter,false,9,sfx_shovel1,sfx_shovel2,sfx_shovel3);
        add_screen_shake(9,0,true);
        
        myDirtColor = global.dirtColor;
        
        repeat(irandom_range(3,8)) instance_create(x,y,fx_digDirt);
        digRateCurrent = 0;
    
        if (!isDigging)
        {
            var dist = point_distance(x,y,obj_digSpot.x,obj_digSpot.y);
            if (dist &lt;= digStartDistance)
            {
                isDigging = true;
                
                audio_play_sound(sfx_relic_on,00,false); //Dig Spot Found Sound Will Go Here Someday
                
                if instance_exists(fx_bigMessage) with (fx_bigMessage) instance_destroy();
                var announceRelic = instance_create(x,y,fx_bigMessage);
                announceRelic.textBig = loc_key("HUD_RELIC_FOUND");
                if (global.input[1] == K_INPUT_KEYBOARD) announceRelic.textSmall = loc_key("HUD_RELIC_FOUND_KEY");
                else announceRelic.textSmall = loc_key("HUD_RELIC_FOUND_JOY");
            }
            else instance_create(x,y,fx_detector);
        }
        else
        {
            digDepth = obj_digSpot.digDepth;
            digDepth += digSpeed;
            obj_digSpot.digDepth = digDepth;
            repeat(irandom_range(1,2)) instance_create(x,y,obj_pickup_coin);
        }
    }
}
else isDigging = false;

if (digRateCurrent &lt; digRate) digRateCurrent++;

if (isDigging)
{
    if digDepth &gt;= digDepthMax
    {
        isDigging = false;
        digDepth = 0;
        digRateCurrent = digRate;
        
        //Feedback "Relic Unlocked goes here"
        
        draw_persistent(spr_digPile,2,x,y,1,1,0,myDirtColor,1);
        
        with (obj_digSpot) activate = true;
        global.relicDetected = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>203</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_kill_object</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Event + Digging

if (!isDigging) 
{
    draw_self();
    if (animation_current == 'dig') draw_sprite_ext(spr_shovel_dig,image_index,x,y,image_xscale,image_yscale,image_angle,image_blend,image_alpha);
}
else{
    image_xscale = 1;
    draw_sprite_part( sprite_index,image_index,0,0,sprite_width,sprite_height-digDepth,x-sprite_xoffset,(y-sprite_yoffset)+digDepth );
   
    if (animation_current != 'dig') draw_sprite(spr_shovel_idle,image_index,x,y);
    else draw_sprite_part( spr_shovel_dig,image_index,0,0,sprite_width,sprite_height-digDepth,x-sprite_xoffset,(y-sprite_yoffset)+digDepth );
    
    var digProgress = digDepthMax/3;
    var digImage = 0;
    
    if (digDepth &lt; digProgress) digImage = 0;
    if (digDepth &gt;= digProgress) &amp;&amp; (digDepth &lt; (digProgress*2)) digImage = 1;
    if (digDepth &gt;= (digProgress*2)) digImage = 2;
 
    draw_sprite_ext(spr_digPile,digImage,x,y,1,1,0,myDirtColor,1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>36,36</point>
    <point>36,36</point>
  </PhysicsShapePoints>
</object>
